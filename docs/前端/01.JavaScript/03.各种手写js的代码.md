---
title: 各种手写JS代码
date: 2022-3-22 16:00:51
permalink: /javascript/sjio12
categories:
  - JavaScript
tags:
  - JavaScript
---

# 各种手写 JS 代码

## 通用柯里化函数

```js
const carry = (fn, ...args) => {
  return (..._args) => {
    _args.unshift(...args)
    return _args.length < fn.length ? carry(fn, ..._args) : fn(..._args)
  }
}

const add = carry(function (a, b, c, d) {
  return a + b + c + d
})

console.log(add(1)(2, 3)(4))
```

## LRU 缓存算法

```js
class LRUCache {
  constructor(capacity = 10) {
    this.map = new Map()
    this.capacity = capacity
  }

  get(key) {
    if (!this.map.has(key)) return -1
    const value = this.map.get(key)
    this.map.delete(key)
    this.map.set(key, value)
    return value
  }

  put(key, value) {
    if (this.map.has(key)) {
      this.map.delete(key)
    }
    this.map.set(key, value)
    while (this.map.size > this.capacity) {
      this.map.delete(this.map.keys().next().value)
    }
  }
}
```

## 列表转树

```js
function listToTree(data) {
  const temp = {}
  const treeData = []
  for (let i = 0; i < data.length; i++) {
    temp[data[i].id] = data[i]
  }
  for (let i in temp) {
    if (+temp[i].parentId != 0) {
      if (!temp[temp[i].parentId].children) {
        temp[temp[i].parentId].children = []
      }
      temp[temp[i].parentId].children.push(temp[i])
    } else {
      treeData.push(temp[i])
    }
  }
  return treeData
}
```

## 树转列表

```js
function treeToList(data) {
  let res = []
  const dfs = tree => {
    tree.forEach(item => {
      if (item.children) {
        dfs(item.children)
        delete item.children
      }
      res.push(item)
    })
  }
  dfs(data)
  return res
}
```

## ajax

```js
const ajax = ({ url, method, body, headers }) => {
  return new Promise((resolve, reject) => {
    const request = new XMLHttpRequest()
    request.open(method, url)
    for (const key in headers) {
      request.setRequestHeader(key, headers[key])
    }
    request.onreadystatechange = () => {
      if (request.readyState === 4) {
        if (request.status >= 200 && request.status < 300) {
          resolve(request.responseText)
        } else if (request.status >= 400) {
          reject(request)
        }
      }
    }
    request.send(body)
  })
}
```

## Promise

```js
class Mypromise {
  constructor(fn) {
    // 表示状态
    this.state = 'pending'
    // 表示then注册的成功函数
    this.successFun = []
    // 表示then注册的失败函数
    this.failFun = []

    let resolve = val => {
      // 保持状态改变不可变（resolve和reject只准触发一种）
      if (this.state !== 'pending') return

      // 成功触发时机  改变状态 同时执行在then注册的回调事件
      this.state = 'success'
      // 为了保证then事件先注册（主要是考虑在promise里面写同步代码） promise规范 这里为模拟异步
      setTimeout(() => {
        // 执行当前事件里面所有的注册函数
        this.successFun.forEach(item => item.call(this, val))
      })
    }

    let reject = err => {
      if (this.state !== 'pending') return
      // 失败触发时机  改变状态 同时执行在then注册的回调事件
      this.state = 'fail'
      // 为了保证then事件先注册（主要是考虑在promise里面写同步代码） promise规范 这里模拟异步
      setTimeout(() => {
        this.failFun.forEach(item => item.call(this, err))
      })
    }
    // 调用函数
    try {
      fn(resolve, reject)
    } catch (error) {
      reject(error)
    }
  }

  // 实例方法 then
  then(resolveCallback, rejectCallback) {
    // 判断回调是否是函数
    resolveCallback =
      typeof resolveCallback !== 'function' ? v => v : resolveCallback
    rejectCallback =
      typeof rejectCallback !== 'function'
        ? err => {
            throw err
          }
        : rejectCallback
    // 为了保持链式调用  继续返回promise
    return new Mypromise((resolve, reject) => {
      // 将回调注册到successFun事件集合里面去
      this.successFun.push(val => {
        try {
          // 执行回调函数
          let x = resolveCallback(val)
          //（最难的一点）
          // 如果回调函数结果是普通值 那么就resolve出去给下一个then链式调用  如果是一个promise对象（代表又是一个异步） 那么调用x的then方法 将resolve和reject传进去 等到x内部的异步 执行完毕的时候（状态完成）就会自动执行传入的resolve 这样就控制了链式调用的顺序
          x instanceof Mypromise ? x.then(resolve, reject) : resolve(x)
        } catch (error) {
          reject(error)
        }
      })

      this.failFun.push(val => {
        try {
          // 执行回调函数
          let x = rejectCallback(val)
          x instanceof Mypromise ? x.then(resolve, reject) : reject(x)
        } catch (error) {
          reject(error)
        }
      })
    })
  }
  // 静态方法
  static all(promiseArr) {
    let result = []
    // 声明一个计数器 每一个promise返回就加一
    let count = 0
    return new Mypromise((resolve, reject) => {
      for (let i = 0; i < promiseArr.length; i++) {
        // 这里用 Promise.resolve包装一下 防止不是Promise类型传进来
        Promise.resolve(promiseArr[i]).then(
          res => {
            // 这里不能直接push数组  因为要控制顺序一一对应(感谢评论区指正)
            result[i] = res
            count++
            // 只有全部的promise执行成功之后才resolve出去
            if (count === promiseArr.length) {
              resolve(result)
            }
          },
          err => {
            reject(err)
          }
        )
      }
    })
  }
  // 静态方法
  static race(promiseArr) {
    return new Mypromise((resolve, reject) => {
      for (let i = 0; i < promiseArr.length; i++) {
        Promise.resolve(promiseArr[i]).then(
          res => {
            // promise数组只要有任何一个promise 状态变更  就可以返回
            resolve(res)
          },
          err => {
            reject(err)
          }
        )
      }
    })
  }
}
```

## 防抖

```js
// 防抖
const debounce = (fn, delay = 300) => {
  let timer
  return (...args) => {
    timer && clearTimeout(timer)
    timer = setTimeout(() => {
      fn.apply(this, args)
    }, delay)
  }
}
```

## 节流

```js
function throttle(fn, delay) {
  let flag = true
  return (...args) => {
    if (!flag) return
    flag = false
    timer = setTimeout(() => {
      fn.apply(this, args)
      flag = true
    }, delay)
  }
}
```

## 深拷贝

```js
function isObject(val) {
  return typeof val === 'object' && val !== null
}

function deepClone(obj, hash = new WeakMap()) {
  if (!isObject(obj)) return obj
  if (hash.has(obj)) {
    return hash.get(obj)
  }
  let target = Array.isArray(obj) ? [] : {}
  hash.set(obj, target)
  Reflect.ownKeys(obj).forEach(item => {
    if (isObject(obj[item])) {
      target[item] = deepClone(obj[item], hash)
    } else {
      target[item] = obj[item]
    }
  })

  return target
}
```

## new

```js
function myNew(fn, ...args) {
  let obj = Object.create(fn.prototype)
  let res = fn.call(obj, ...args)
  if (res && (typeof res === 'object' || typeof res === 'function')) {
    return res
  }
  return obj
}
```

## 继承

```js
function Parent(name) {
  this.name = name
  this.sing = () => {
    console.log('sing')
  }
}
Parent.prototype.dance = () => {
  console.log('dance')
}

function Children(name, age) {
  Parent.call(this, name)
  this.age = age
}
Children.prototype.rap = () => {
  console.log('rap')
}

Children.prototype = Object.create(Parent.prototype)
Children.prototype.constructor = Children
```

## call

```js
Function.prototype.myCall = function (context = window, ...args) {
  const key = Symbol()
  context[key] = this
  return context[key](...args)
}
```

## apply

```js
Function.prototype.myApply = function (context = window, ...args) {
  const key = Symbol()
  context[key] = this
  return context[key](...args)
}
```

## bind

```js
Function.prototype.myBind = function (context = window, ...args) {
  const key = Symbol()
  context[key] = this
  const _this = this
  const result = function (...innerArgs) {
    if (this instanceof _this === true) {
      this[key] = _this
      this[key](...[...args, ...innerArgs])
    } else {
      context[key](...[...args, ...innerArgs])
    }
  }
  result.prototype = Object.create(this.prototype)
  return result
}
```
